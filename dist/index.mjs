import{combine as e,createStore as r,createEvent as t,sample as i,merge as o}from"effector";import{useUnit as n}from"effector-solid";const s={store:function({init:e,domain:t,existing:i},o){return i||(t?t.createStore(e,o):r(e,o))},event:function({domain:e,existing:r}){return r||(e?e.createEvent():t())}};function u(r,t,i){var o,n,u,l,a,d,c,v,f,m,h,$;const g="function"==typeof t.init?t.init():t.init,x=s.store({domain:i,existing:null===(o=t.units)||void 0===o?void 0:o.$value,init:g},{sid:`${r}-$value`}),p=s.store({domain:i,existing:null===(n=t.units)||void 0===n?void 0:n.$errors,init:[]},{sid:`${r}-$errors`}),V=p.map((e=>e[0]?e[0]:null)),E=s.store({domain:i,existing:null===(u=t.units)||void 0===u?void 0:u.$initValue,init:g},{sid:`${r}-$initValue`}),y=s.store({domain:i,existing:null===(l=t.units)||void 0===l?void 0:l.$isTouched,init:!1},{sid:`${r}-$touched`}),T=e(x,E,((e,r)=>e!==r)),b=s.event({domain:i,existing:null===(a=t.units)||void 0===a?void 0:a.onChange}),O=s.event({domain:i,existing:null===(d=t.units)||void 0===d?void 0:d.onBlur}),F=s.event({domain:i,existing:null===(c=t.units)||void 0===c?void 0:c.changed}),S=s.event({domain:i,existing:null===(v=t.units)||void 0===v?void 0:v.addError}),k=s.event({domain:i,existing:null===(f=t.units)||void 0===f?void 0:f.validate}),w=s.event({domain:i,existing:null===(m=t.units)||void 0===m?void 0:m.resetErrors}),D=s.event({domain:i,existing:null===(h=t.units)||void 0===h?void 0:h.resetValue}),B=s.event({domain:i,existing:null===($=t.units)||void 0===$?void 0:$.reset}),C=V.map((e=>null===e)),P=V.map((e=>(null==e?void 0:e.errorText)||"")),I=e({value:x,errors:p,firstError:V,isValid:C,isDirty:T,isTouched:y}),j={value:x,initValue:E,isValid:C,isDirty:T,touched:y,errors:p,firstError:V,errorText:P,onChange:b,onBlur:O,addError:S,validate:k,reset:B,resetErrors:w,resetValue:D};return{changed:F,name:r,$initValue:E,$value:x,$errors:p,$firstError:V,$errorText:P,$isValid:C,$isDirty:T,$isTouched:y,$touched:y,$field:I,onChange:b,onBlur:O,addError:S,validate:k,set:b,reset:B,resetErrors:w,resetValue:D,filter:t.filter,"@@unitShape":()=>j}}function l(t){const{form:n,field:s,fieldConfig:u}=t,l=u.rules||[],a=n.validateOn||["submit"],d=u.validateOn||[],{$value:c,$errors:v,onBlur:f,changed:m,addError:h,validate:$,resetErrors:g,resetValue:x,reset:p}=s,V="function"==typeof l?r([],{sid:`${s.name}-$rulesSources`}):e(l.map((({source:e},t)=>{const i=`${s.name}-$rulesSources-${t}`;return e||r(null,{sid:i})}))),E=function(e){return(r,t,i)=>{const o=[],n="function"==typeof e?e(r,t):e;for(const[e,s]of n.entries()){const n=i?i[e]:null,u=s.validator(r,t,n);"boolean"!=typeof u||u||o.push({rule:s.name,errorText:s.errorText,value:r}),"object"!=typeof u||u.isValid||o.push({rule:s.name,errorText:u.errorText,value:r})}return o}}(l),y=new Set([...a,...d]),T=[];if(y.has("submit")){const r=i({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:n.submit});T.push(r)}y.has("blur")&&T.push(i({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:f})),y.has("change")&&T.push(i({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:o([m,x,n.resetValues])})),T.push(i({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:$})),T.push(i({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:n.validate}));const b=i({source:c,clock:h,fn:(e,{rule:r,errorText:t})=>({rule:r,value:e,errorText:t})}),O=i({source:c,clock:n.addErrors,fn:(e,r)=>({value:e,newErrors:r})});v.on(T,((e,{form:r,fieldValue:t,rulesSources:i})=>E(t,r,i))).on(b,((e,r)=>[r,...e])).on(O,((e,{value:r,newErrors:t})=>{const i=[];for(const e of t)e.field===s.name&&i.push({value:r,rule:e.rule,errorText:e.errorText});return[...i,...e]})).reset(g,n.reset,p,n.resetErrors),y.has("change")||v.reset(m)}function a({field:e,form:r}){const{$value:t,$initValue:n,$touched:s,onChange:u,changed:l,name:a,reset:d,resetValue:c,filter:v}=e,{setForm:f,setInitialForm:m,resetForm:h,resetTouched:$,resetValues:g}=r,x=i({source:n,clock:o([d,c,g,h])});s.on(l,(()=>!0)).reset(d,h,$),i(v?{source:u,filter:v,target:l}:{source:u,filter:()=>!0,target:l}),n.on(m,((e,r)=>r.hasOwnProperty(a)?r[a]:e)),t.on(l,((e,r)=>r)).on([f,m],((e,r)=>r.hasOwnProperty(a)?r[a]:e)).on(x,((e,r)=>r))}function d(r){const{filter:t,domain:o,fields:n,validateOn:d,units:c}=r,v={},f=[],m=[];for(const e in n){if(!n.hasOwnProperty(e))continue;const r=u(e,n[e],o);v[e]=r,f.push(r.$isDirty),m.push(r.$touched)}const h=function(r){const t={};for(const e in r)r.hasOwnProperty(e)&&(t[e]=r[e].$value);return e(t)}(v),$=function(r){const t=[];for(const e in r){if(!r.hasOwnProperty(e))continue;const{$firstError:i}=r[e];t.push(i)}return e(t).map((e=>e.every((e=>null===e))))}(v),g=t?e($,t,((e,r)=>e&&r)):$,x=e(f).map((e=>e.some(Boolean))),p=e(m).map((e=>e.some(Boolean))),V=e({isValid:$,isDirty:x,touched:p}),E=s.event({domain:o,existing:null==c?void 0:c.validate}),y=s.event({domain:o,existing:null==c?void 0:c.submit}),T=s.event({domain:o,existing:null==c?void 0:c.formValidated}),b=s.event({domain:o,existing:null==c?void 0:c.setInitialForm}),O=s.event({domain:o,existing:null==c?void 0:c.setForm}),F=s.event({domain:o,existing:null==c?void 0:c.addErrors}),S=s.event({domain:o,existing:null==c?void 0:c.reset}),k=s.event({domain:o,existing:null==c?void 0:c.resetValues}),w=s.event({domain:o,existing:null==c?void 0:c.resetErrors}),D=s.event({domain:o,existing:null==c?void 0:c.resetTouched}),B=i({source:h,clock:y}),C=i({source:h,clock:E});for(const e in v){if(!v.hasOwnProperty(e))continue;const r=n[e],t=v[e];a({form:{setForm:O,setInitialForm:b,resetForm:S,resetTouched:D,resetValues:k},field:t}),l({form:{$values:h,submit:y,reset:S,addErrors:F,resetValues:k,resetErrors:w,validate:E,validateOn:d},fieldConfig:r,field:t})}i({source:B,filter:g,target:T}),i({source:C,filter:g,target:T});const P={isValid:$,isDirty:x,touched:p,submit:y,reset:S,addErrors:F,validate:E,setForm:O,setInitialForm:b,resetTouched:D,resetValues:k,resetErrors:w,formValidated:T};return{fields:v,$values:h,$eachValid:$,$isValid:$,$isDirty:x,$touched:p,$meta:V,submit:y,validate:E,resetTouched:D,addErrors:F,reset:S,resetValues:k,resetErrors:w,setForm:O,setInitialForm:b,set:O,formValidated:T,"@@unitShape":()=>P}}const c=(e,r)=>{const t=Object.keys(e.fields);let i={};return(e=>[Object,Array].includes((e||{}).constructor)&&0===Object.entries(e||{}).length)(r)?t.forEach((r=>{i={...i,[r]:n(e.fields[r])}})):r.forEach((r=>{i={...i,[r]:n(e.fields[r])}})),i},v=(e,r)=>{const t=n(e),i=c(e,r);return{...t,submit:e=>{e.preventDefault(),t.submit()},values:i}};export{d as createForm,v as useForm,c as useFormSignals};
